---
alwaysApply: true
---
# Data Retrieval & Server Actions Guidelines

This project follows strict patterns for data access and mutations with Zod validation.

## üèóÔ∏è Architecture Overview

**ALL database operations MUST go through helper functions in the `db/queries` directory.**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Client          ‚îÇ
‚îÇ Components      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Server          ‚îÇ      ‚îÇ Server           ‚îÇ
‚îÇ Components      ‚îÇ ---> ‚îÇ Actions          ‚îÇ
‚îÇ (READ)          ‚îÇ      ‚îÇ (CREATE/UPDATE/  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ  DELETE)         ‚îÇ
         ‚îÇ               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                        ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚Üì
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ db/queries   ‚îÇ
              ‚îÇ (Helper      ‚îÇ
              ‚îÇ  Functions)  ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚Üì
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ Database     ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Core Principles

### 1. Database Queries ‚Üí Helper Functions in `db/queries/`
**NEVER write database queries directly in Server Components or Server Actions.**

All database interactions must go through reusable query functions in the `db/queries` directory.

#### ‚úÖ CORRECT - Query functions in `db/queries`

```typescript
// db/queries/deck-queries.ts
import { db } from "@/db";
import { decksTable, cardsTable } from "@/db/schema";
import { eq, and } from "drizzle-orm";

/**
 * Get all decks for a specific user
 */
export async function getUserDecks(userId: string) {
  return await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
}

/**
 * Get a specific deck by ID (with user ownership check)
 */
export async function getDeckById(deckId: number, userId: string) {
  const [deck] = await db
    .select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
  
  return deck;
}

/**
 * Get all cards for a specific deck (with user ownership check)
 */
export async function getDeckCards(deckId: number, userId: string) {
  // Verify deck ownership first
  const deck = await getDeckById(deckId, userId);
  if (!deck) return null;
  
  return await db
    .select()
    .from(cardsTable)
    .where(eq(cardsTable.deckId, deckId));
}
```

#### ‚úÖ CORRECT - Server Component using query functions

```typescript
// app/decks/page.tsx
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { getUserDecks } from "@/db/queries/deck-queries";

export default async function DecksPage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect("/"); // Redirect to homepage where sign-in/sign-up modals are available
  }
  
  // Use query function from db/queries
  const decks = await getUserDecks(userId);
  
  return <div>{/* Render decks */}</div>;
}
```

#### ‚ùå WRONG - Direct database query in Server Component

```typescript
// app/decks/page.tsx
import { db } from "@/db";
import { decksTable } from "@/db/schema";
import { eq } from "drizzle-orm";

export default async function DecksPage() {
  // ‚ùå DON'T query database directly
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
  
  return <div>{/* ... */}</div>;
}
```

#### ‚ùå WRONG - Client Component fetching data

```typescript
"use client";

import { useEffect, useState } from "react";

export default function DecksPage() {
  const [decks, setDecks] = useState([]);
  
  useEffect(() => {
    // ‚ùå Don't fetch data in Client Components via API routes
    fetch("/api/decks").then(/* ... */);
  }, []);
  
  return <div>{/* ... */}</div>;
}
```

### 2. Database Mutations ‚Üí Helper Functions in `db/queries/`
**NEVER write database mutations directly in Server Actions.**

All INSERT, UPDATE, DELETE operations must go through mutation functions in the `db/queries` directory.

#### ‚úÖ CORRECT - Mutation functions in `db/queries`

```typescript
// db/queries/deck-queries.ts
import { db } from "@/db";
import { decksTable } from "@/db/schema";
import { eq, and } from "drizzle-orm";

/**
 * Create a new deck for a user
 */
export async function createDeckForUser(
  userId: string,
  data: { name: string; description?: string }
) {
  const [deck] = await db
    .insert(decksTable)
    .values({
      userId,
      name: data.name,
      description: data.description,
    })
    .returning();
  
  return deck;
}

/**
 * Update a deck (with user ownership check)
 */
export async function updateDeckForUser(
  deckId: number,
  userId: string,
  data: { name: string; description?: string }
) {
  // Verify ownership first
  const existing = await getDeckById(deckId, userId);
  if (!existing) {
    throw new Error("Deck not found or unauthorized");
  }
  
  const [updated] = await db
    .update(decksTable)
    .set({
      name: data.name,
      description: data.description,
      updatedAt: new Date(),
    })
    .where(eq(decksTable.id, deckId))
    .returning();
  
  return updated;
}

/**
 * Delete a deck (with user ownership check)
 */
export async function deleteDeckForUser(deckId: number, userId: string) {
  // Verify ownership first
  const existing = await getDeckById(deckId, userId);
  if (!existing) {
    throw new Error("Deck not found or unauthorized");
  }
  
  await db.delete(decksTable).where(eq(decksTable.id, deckId));
}
```

#### ‚úÖ CORRECT - Server Action using mutation functions

```typescript
// app/actions/deck-actions.ts
"use server";

import { auth } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";
import { z } from "zod";
import { createDeckForUser, updateDeckForUser, deleteDeckForUser } from "@/db/queries/deck-queries";

// Define Zod schema
const createDeckSchema = z.object({
  name: z.string().min(1, "Name is required").max(255),
  description: z.string().max(1000).optional(),
});

type CreateDeckInput = z.infer<typeof createDeckSchema>;

export async function createDeck(input: CreateDeckInput) {
  // 1. Authenticate
  const { userId } = await auth();
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // 2. Validate with Zod
  const validated = createDeckSchema.parse(input);
  
  // 3. Use mutation function from db/queries
  const deck = await createDeckForUser(userId, validated);
  
  // 4. Revalidate affected paths
  revalidatePath("/decks");
  
  return deck;
}
```

#### ‚ùå WRONG - Direct database mutation in Server Action

```typescript
// app/actions/deck-actions.ts
"use server";

import { db } from "@/db";
import { decksTable } from "@/db/schema";

export async function createDeck(input: CreateDeckInput) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  
  const validated = createDeckSchema.parse(input);
  
  // ‚ùå DON'T mutate database directly
  const [deck] = await db
    .insert(decksTable)
    .values({ userId, ...validated })
    .returning();
  
  revalidatePath("/decks");
  return deck;
}
```

#### ‚ùå WRONG - Using FormData as parameter type

```typescript
"use server";

export async function createDeck(formData: FormData) {
  // ‚ùå Don't use FormData directly - use typed objects
  const name = formData.get("name");
  // ...
}
```

### 3. Data Validation ‚Üí Zod ALWAYS
**All data passed to Server Actions must be validated using Zod schemas.**

#### ‚úÖ CORRECT - Zod validation in Server Action + Query function

```typescript
// db/queries/card-queries.ts
import { db } from "@/db";
import { cardsTable, decksTable } from "@/db/schema";
import { eq, and } from "drizzle-orm";

/**
 * Update a card (with user ownership check via deck)
 */
export async function updateCardForUser(
  cardId: number,
  userId: string,
  data: { front: string; back: string }
) {
  // Verify card belongs to user's deck
  const result = await db
    .select()
    .from(cardsTable)
    .leftJoin(decksTable, eq(cardsTable.deckId, decksTable.id))
    .where(and(
      eq(cardsTable.id, cardId),
      eq(decksTable.userId, userId)
    ));
  
  if (!result[0]) {
    throw new Error("Card not found or unauthorized");
  }
  
  const [updated] = await db
    .update(cardsTable)
    .set({
      front: data.front,
      back: data.back,
      updatedAt: new Date(),
    })
    .where(eq(cardsTable.id, cardId))
    .returning();
  
  return updated;
}
```

```typescript
// app/actions/card-actions.ts
"use server";

import { auth } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";
import { z } from "zod";
import { updateCardForUser } from "@/db/queries/card-queries";

// 1. Define schema
const updateCardSchema = z.object({
  id: z.number().positive(),
  front: z.string().min(1, "Question is required"),
  back: z.string().min(1, "Answer is required"),
});

// 2. Infer TypeScript type
type UpdateCardInput = z.infer<typeof updateCardSchema>;

// 3. Use typed parameter and validate
export async function updateCard(input: UpdateCardInput) {
  // Authenticate
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  
  // Validate
  const validated = updateCardSchema.parse(input);
  
  // Use mutation function from db/queries
  const updated = await updateCardForUser(
    validated.id,
    userId,
    { front: validated.front, back: validated.back }
  );
  
  revalidatePath("/decks");
  return updated;
}
```

#### ‚ùå WRONG - Direct database mutation without query function

```typescript
// app/actions/card-actions.ts
"use server";

import { db } from "@/db";
import { cardsTable } from "@/db/schema";
import { eq } from "drizzle-orm";

export async function updateCard(input: UpdateCardInput) {
  const validated = updateCardSchema.parse(input);
  
  // ‚ùå DON'T mutate database directly
  await db
    .update(cardsTable)
    .set({
      front: validated.front,
      back: validated.back,
      updatedAt: new Date(),
    })
    .where(eq(cardsTable.id, validated.id));
}
```

#### ‚ùå WRONG - No Zod validation

```typescript
export async function updateCard(input: any) {
  // ‚ùå Missing validation - data could be malformed
  await updateCardForUser(input.id, userId, input);
}
```

## Complete Example: CRUD Operations with db/queries

### Step 1: Query Functions in `db/queries/`

```typescript
// db/queries/deck-queries.ts
import { db } from "@/db";
import { decksTable, cardsTable } from "@/db/schema";
import { eq, and } from "drizzle-orm";

// ============ READ OPERATIONS ============

export async function getUserDecks(userId: string) {
  return await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
}

export async function getDeckById(deckId: number, userId: string) {
  const [deck] = await db
    .select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
  
  return deck;
}

export async function getDeckCards(deckId: number, userId: string) {
  // Verify deck ownership first
  const deck = await getDeckById(deckId, userId);
  if (!deck) return null;
  
  return await db
    .select()
    .from(cardsTable)
    .where(eq(cardsTable.deckId, deckId));
}

// ============ WRITE OPERATIONS ============

export async function createDeckForUser(
  userId: string,
  data: { name: string; description?: string }
) {
  const [deck] = await db
    .insert(decksTable)
    .values({
      userId,
      name: data.name,
      description: data.description,
    })
    .returning();
  
  return deck;
}

export async function updateDeckForUser(
  deckId: number,
  userId: string,
  data: { name: string; description?: string }
) {
  // Verify ownership
  const existing = await getDeckById(deckId, userId);
  if (!existing) {
    throw new Error("Deck not found or unauthorized");
  }
  
  const [updated] = await db
    .update(decksTable)
    .set({
      name: data.name,
      description: data.description,
      updatedAt: new Date(),
    })
    .where(eq(decksTable.id, deckId))
    .returning();
  
  return updated;
}

export async function deleteDeckForUser(deckId: number, userId: string) {
  // Verify ownership
  const existing = await getDeckById(deckId, userId);
  if (!existing) {
    throw new Error("Deck not found or unauthorized");
  }
  
  await db.delete(decksTable).where(eq(decksTable.id, deckId));
}
```

### Step 2: Server Component (Read)

```typescript
// app/decks/[deckId]/page.tsx
import { auth } from "@clerk/nextjs/server";
import { notFound, redirect } from "next/navigation";
import { getDeckById, getDeckCards } from "@/db/queries/deck-queries";

export default async function DeckPage({ 
  params 
}: { 
  params: { deckId: string } 
}) {
  const { userId } = await auth();
  if (!userId) redirect("/"); // Redirect to homepage where sign-in/sign-up modals are available
  
  const deckId = parseInt(params.deckId);
  
  // Use query functions from db/queries
  const deck = await getDeckById(deckId, userId);
  if (!deck) notFound();
  
  const cards = await getDeckCards(deckId, userId);
  
  return <DeckView deck={deck} cards={cards || []} />;
}
```

### Step 3: Server Actions (Create, Update, Delete)

```typescript
// app/actions/deck-actions.ts
"use server";

import { auth } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";
import { z } from "zod";
import {
  createDeckForUser,
  updateDeckForUser,
  deleteDeckForUser,
} from "@/db/queries/deck-queries";

// ============ CREATE ============

const createDeckSchema = z.object({
  name: z.string().min(1).max(255),
  description: z.string().max(1000).optional(),
});

type CreateDeckInput = z.infer<typeof createDeckSchema>;

export async function createDeck(input: CreateDeckInput) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  
  const validated = createDeckSchema.parse(input);
  
  // Use mutation function from db/queries
  const deck = await createDeckForUser(userId, validated);
  
  revalidatePath("/decks");
  return deck;
}

// ============ UPDATE ============

const updateDeckSchema = z.object({
  id: z.number().positive(),
  name: z.string().min(1).max(255),
  description: z.string().max(1000).optional(),
});

type UpdateDeckInput = z.infer<typeof updateDeckSchema>;

export async function updateDeck(input: UpdateDeckInput) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  
  const validated = updateDeckSchema.parse(input);
  
  // Use mutation function from db/queries
  const updated = await updateDeckForUser(
    validated.id,
    userId,
    { name: validated.name, description: validated.description }
  );
  
  revalidatePath("/decks");
  revalidatePath(`/decks/${validated.id}`);
  return updated;
}

// ============ DELETE ============

const deleteDeckSchema = z.object({
  id: z.number().positive(),
});

type DeleteDeckInput = z.infer<typeof deleteDeckSchema>;

export async function deleteDeck(input: DeleteDeckInput) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  
  const validated = deleteDeckSchema.parse(input);
  
  // Use mutation function from db/queries
  await deleteDeckForUser(validated.id, userId);
  
  revalidatePath("/decks");
}
```

### Step 4: Client Component (UI with Server Actions)

```typescript
// components/create-deck-form.tsx
"use client";

import { useState } from "react";
import { createDeck } from "@/app/actions/deck-actions";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

export function CreateDeckForm() {
  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  
  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    
    // Call Server Action with typed object (NOT FormData)
    // Server Action handles validation and calls db/queries function
    await createDeck({
      name,
      description: description || undefined,
    });
    
    setName("");
    setDescription("");
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <Input 
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Deck name"
      />
      <Input 
        value={description}
        onChange={(e) => setDescription(e.target.value)}
        placeholder="Description (optional)"
      />
      <Button type="submit">Create Deck</Button>
    </form>
  );
}
```

## Rules Summary

### ‚úÖ Always Do This

**Database Operations:**
- ‚úÖ **Create query/mutation functions in `db/queries/` directory**
- ‚úÖ **All database queries MUST go through `db/queries/` helper functions**
- ‚úÖ **All database mutations MUST go through `db/queries/` helper functions**
- ‚úÖ **Query functions handle userId filtering and ownership verification**
- ‚úÖ **Organize query files by domain** (e.g., `deck-queries.ts`, `card-queries.ts`)

**Server Components:**
- ‚úÖ **Call query functions from `db/queries/` in Server Components**
- ‚úÖ **Authenticate user with Clerk before calling query functions**
- ‚úÖ **Pass userId to query functions for data isolation**

**Server Actions:**
- ‚úÖ **Define Zod schemas for all Server Action inputs**
- ‚úÖ **Infer TypeScript types from Zod schemas** using `z.infer<typeof schema>`
- ‚úÖ **Validate all Server Action inputs** with `schema.parse(input)`
- ‚úÖ **Use typed objects as Server Action parameters** (NOT FormData)
- ‚úÖ **Call mutation functions from `db/queries/` after validation**
- ‚úÖ **Call `revalidatePath()` after mutations** to refresh cached data
- ‚úÖ **Verify user authentication in Server Actions** before calling query functions

**Security:**
- ‚úÖ **Always filter by userId in query functions**
- ‚úÖ **Verify resource ownership in mutation functions**
- ‚úÖ **Handle ownership checks in `db/queries/` functions, not in Server Actions**

### ‚ùå Never Do This

**Database Operations:**
- ‚ùå **NEVER write database queries directly in Server Components**
- ‚ùå **NEVER write database queries directly in Server Actions**
- ‚ùå **NEVER import `db` from "@/db" in Server Components or Actions** (use `db/queries` instead)
- ‚ùå **NEVER bypass `db/queries/` helper functions**

**Data Fetching:**
- ‚ùå Don't fetch data in Client Components via API routes
- ‚ùå Don't create API routes for CRUD operations
- ‚ùå Don't query the database without going through `db/queries/`

**Server Actions:**
- ‚ùå Don't use `FormData` as Server Action parameter type
- ‚ùå Don't skip Zod validation
- ‚ùå Don't use `any` or untyped parameters
- ‚ùå Don't forget to revalidate paths after mutations
- ‚ùå Don't forget authentication checks
- ‚ùå Don't perform database operations directly (use `db/queries/` functions)

## Error Handling

### Query Function Error Handling

```typescript
// db/queries/deck-queries.ts
export async function getDeckById(deckId: number, userId: string) {
  const [deck] = await db
    .select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
  
  // Return null if not found (let caller decide how to handle)
  return deck || null;
}

export async function updateDeckForUser(
  deckId: number,
  userId: string,
  data: { name: string; description?: string }
) {
  const existing = await getDeckById(deckId, userId);
  
  // Throw error for unauthorized access
  if (!existing) {
    throw new Error("Deck not found or unauthorized");
  }
  
  try {
    const [updated] = await db
      .update(decksTable)
      .set({ ...data, updatedAt: new Date() })
      .where(eq(decksTable.id, deckId))
      .returning();
    
    return updated;
  } catch (error) {
    // Re-throw with more context
    throw new Error(`Failed to update deck: ${error.message}`);
  }
}
```

### Server Action Error Handling

```typescript
// app/actions/deck-actions.ts
"use server";

import { auth } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";
import { z } from "zod";
import { updateDeckForUser } from "@/db/queries/deck-queries";

const updateDeckSchema = z.object({
  id: z.number().positive(),
  name: z.string().min(1, "Name is required"),
  description: z.string().max(1000).optional(),
});

type UpdateDeckInput = z.infer<typeof updateDeckSchema>;

export async function updateDeck(input: UpdateDeckInput) {
  try {
    // 1. Authenticate
    const { userId } = await auth();
    if (!userId) {
      return { 
        success: false, 
        error: "You must be logged in to update decks" 
      };
    }
    
    // 2. Validate - throws ZodError if invalid
    const validated = updateDeckSchema.parse(input);
    
    // 3. Call query function - may throw if not found/unauthorized
    const updated = await updateDeckForUser(
      validated.id,
      userId,
      { name: validated.name, description: validated.description }
    );
    
    // 4. Revalidate
    revalidatePath("/decks");
    revalidatePath(`/decks/${validated.id}`);
    
    return { success: true, data: updated };
  } catch (error) {
    // Handle Zod validation errors
    if (error instanceof z.ZodError) {
      return { 
        success: false, 
        error: error.errors[0].message 
      };
    }
    
    // Handle query function errors (ownership, not found, etc.)
    if (error instanceof Error) {
      return {
        success: false,
        error: error.message
      };
    }
    
    // Handle unexpected errors
    console.error("Unexpected error in updateDeck:", error);
    return {
      success: false,
      error: "An unexpected error occurred"
    };
  }
}
```

### Error Handling Best Practices

1. **Query functions should throw errors** for:
   - Unauthorized access (ownership violations)
   - Database constraint violations
   - Unexpected database errors

2. **Query functions should return null** for:
   - Resource not found (let caller decide how to handle)

3. **Server Actions should catch and handle**:
   - Authentication errors ‚Üí Return user-friendly message
   - Zod validation errors ‚Üí Return validation error message
   - Query function errors ‚Üí Return error message to user
   - Unexpected errors ‚Üí Log and return generic message

4. **Never expose sensitive information** in error messages sent to client

## Directory Structure

```
src/
‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts              # Database connection
‚îÇ   ‚îú‚îÄ‚îÄ schema.ts             # Database schema
‚îÇ   ‚îî‚îÄ‚îÄ queries/              # ‚≠ê ALL database operations go here
‚îÇ       ‚îú‚îÄ‚îÄ deck-queries.ts   # Deck-related queries & mutations
‚îÇ       ‚îî‚îÄ‚îÄ card-queries.ts   # Card-related queries & mutations
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ actions/              # Server Actions (validation + calling db/queries)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck-actions.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ card-actions.ts
‚îÇ   ‚îî‚îÄ‚îÄ [routes]/
‚îÇ       ‚îî‚îÄ‚îÄ page.tsx          # Server Components (call db/queries for data)
‚îî‚îÄ‚îÄ components/
    ‚îî‚îÄ‚îÄ [client-components].tsx  # Client Components (call Server Actions)
```

## Important Files

- [src/db/schema.ts](mdc:src/db/schema.ts) - Database schema definitions
- [src/db/index.ts](mdc:src/db/index.ts) - Database connection instance
- **[src/db/queries/](mdc:src/db/queries/)** - ‚≠ê **ALL query and mutation helper functions**

## Best Practices

### Query Function Organization

1. **Organize by domain**: Create separate files for each major entity
   - `deck-queries.ts` - All deck-related queries and mutations
   - `card-queries.ts` - All card-related queries and mutations

2. **Clear function naming conventions**:
   - Read operations: `getUserDecks()`, `getDeckById()`, `getDeckCards()`
   - Create operations: `createDeckForUser()`, `createCardForDeck()`
   - Update operations: `updateDeckForUser()`, `updateCardForUser()`
   - Delete operations: `deleteDeckForUser()`, `deleteCardForUser()`

3. **Always accept userId as parameter**: Query functions should ALWAYS receive `userId` to enforce data isolation
   ```typescript
   // ‚úÖ Good - userId is always passed
   export async function getUserDecks(userId: string) { }
   export async function getDeckById(deckId: number, userId: string) { }
   
   // ‚ùå Bad - missing userId parameter
   export async function getDeckById(deckId: number) { }
   ```

4. **Handle ownership verification in query functions**: Don't push this responsibility to Server Actions or Components
   ```typescript
   export async function updateDeckForUser(deckId: number, userId: string, data: any) {
     // Verify ownership HERE in the query function
     const existing = await getDeckById(deckId, userId);
     if (!existing) throw new Error("Not found or unauthorized");
     
     // Then perform the update
     // ...
   }
   ```

5. **Document query functions with JSDoc comments**:
   ```typescript
   /**
    * Get all decks for a specific user
    * @param userId - The authenticated user's ID
    * @returns Array of user's decks
    */
   export async function getUserDecks(userId: string) { }
   ```

### Server Action Organization

1. **Keep Server Actions in dedicated files**: e.g., `app/actions/deck-actions.ts`

2. **Server Actions should be thin wrappers**:
   - Authenticate user (Clerk)
   - Validate input (Zod)
   - Call `db/queries/` function
   - Revalidate paths
   - Return result

3. **Export Zod schemas** if needed in multiple places

4. **Use `revalidatePath()`** to update UI after mutations

5. **Return meaningful data** from Server Actions (the created/updated record)

6. **Handle errors gracefully** with try-catch blocks

7. **Use `redirect()`** for navigation after successful mutations when appropriate

8. **Keep validation logic close to the schema definition**

9. **Document required vs optional fields in schemas**

### General Best Practices

1. **Separation of Concerns**:
   - **`db/queries/`**: Database operations, userId filtering, ownership verification
   - **Server Actions**: Authentication, validation, calling query functions, revalidation
   - **Server Components**: Authentication, calling query functions for data fetching
   - **Client Components**: UI logic, calling Server Actions

2. **Never skip the `db/queries/` layer**: Even for simple queries, always create a query function

3. **Test query functions independently**: Query functions should be pure and testable

4. **Keep query functions reusable**: Design them to be called from multiple places

5. **Type safety everywhere**: Use TypeScript types inferred from Zod schemas and Drizzle tables

## üö® CRITICAL ENFORCEMENT

### This is NOT Optional

The `db/queries/` pattern is **MANDATORY** in this project. There are NO exceptions.

**If you see code that violates these rules, it MUST be refactored immediately.**

### Common Violations to Watch For

#### ‚ùå VIOLATION 1: Direct database queries in Server Components

```typescript
// ‚ùå WRONG - This violates the pattern
import { db } from "@/db";
import { decksTable } from "@/db/schema";

export default async function Page() {
  const decks = await db.select().from(decksTable);
  return <div>...</div>;
}
```

**FIX:** Create a query function in `db/queries/` and use it:

```typescript
// ‚úÖ CORRECT
import { getUserDecks } from "@/db/queries/deck-queries";

export default async function Page() {
  const { userId } = await auth();
  if (!userId) redirect("/");
  
  const decks = await getUserDecks(userId);
  return <div>...</div>;
}
```

#### ‚ùå VIOLATION 2: Direct database mutations in Server Actions

```typescript
// ‚ùå WRONG - This violates the pattern
"use server";
import { db } from "@/db";
import { decksTable } from "@/db/schema";

export async function createDeck(input: any) {
  const [deck] = await db.insert(decksTable).values(input).returning();
  return deck;
}
```

**FIX:** Create a mutation function in `db/queries/` and use it:

```typescript
// ‚úÖ CORRECT
"use server";
import { createDeckForUser } from "@/db/queries/deck-queries";

export async function createDeck(input: CreateDeckInput) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  
  const validated = createDeckSchema.parse(input);
  const deck = await createDeckForUser(userId, validated);
  
  revalidatePath("/decks");
  return deck;
}
```

#### ‚ùå VIOLATION 3: Importing `db` in Server Components or Actions

```typescript
// ‚ùå WRONG - Should never see this import in components or actions
import { db } from "@/db";
```

**CORRECT:** Only import from `db/queries/`:

```typescript
// ‚úÖ CORRECT - This is the ONLY database import allowed in components/actions
import { getUserDecks, createDeckForUser } from "@/db/queries/deck-queries";
```

### Why This Pattern is Mandatory

1. **Centralized Security**: All userId filtering and ownership checks happen in one place
2. **Reusability**: Query functions can be used across multiple components and actions
3. **Testability**: Query functions can be tested independently
4. **Maintainability**: Database logic is organized and easy to find
5. **Consistency**: Enforces a consistent pattern across the entire codebase
6. **Type Safety**: Strong TypeScript types throughout the data layer

### Enforcement Checklist

Before approving ANY code that interacts with the database, verify:

- [ ] No `import { db } from "@/db"` in Server Components or Server Actions
- [ ] All database queries go through `db/queries/` functions
- [ ] All database mutations go through `db/queries/` functions
- [ ] Query functions accept `userId` parameter for user-owned resources
- [ ] Query functions handle ownership verification
- [ ] Server Actions only validate and call query functions
- [ ] Server Components only authenticate and call query functions

**If ANY of these checks fail, the code MUST be refactored before proceeding.**
